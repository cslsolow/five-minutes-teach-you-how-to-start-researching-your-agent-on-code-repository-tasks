# 五分钟教你迭代Agent方法在代码仓库任务上 - written by 陈思霖, Silin Chen

# Baseline

如何选择baseline是一个很好的开始，选择baseline最好：

1. 基于popular的开源框架的方法，谨慎选择个人的从头写的框架，因为这样你以后可以说你精通这个框架，无论是以后研究还是找工作都有益处
2. 模型的选择，开源但水平处在该任务的中游偏上模型常常是个好选择

总而言之，选一个有提升空间的模型和一个popular的agent架构

# 第一步

跑golden patch很重要（@某live和perf），不然可能浪费你大量时间

现在很多流程都是LLM核实，有些bench可能有点瑕疵

分析test cases和issue是否对应也很重要，有些benchmark并没有质量过滤这个流程

# 第二步

开始跑baseline，如何选择超参数也是个很好的问题

1. 既要跑actions数量少的，也要跑原论文的参数。参数少的能告诉你这个框架的一些缺点（比如swe-agent容易一直在检索代码，autocoderover这种把每阶段都规划好的能降低这方面影响）以及是否参数少还会遵循原论文的流程；原参数能帮助你理解原论文的架构

不同的框架比如ReAct（返回json）和tools called（返回具体工具格式）

1. 目前的框架比如mini-swe-agent为了节省tokens会让模型不要输出thought直接调用工具，这不利于研究者理解模型的思考（比如它是一开始就出错了，还是最后一步思考错误）；ReAct框架就改system prompt或者增加demonstration，tools called架构就给每个工具一个叫thought的property，并加入required让模型显式展示自己的思考（但是thought一定要在action前面）

instances数量的选择

1. 建议看一下前人的错误分布，easy ambiguous hard各占三分之一
2. 每个仓库都要有，50个-100个instances较ok
3. ambiguous是指那些 1. 不同模型可能作对也可能failed；2. temp运行多次可能过的 

# 第三步

当你开始做研究的时候

泛读论文每天都要做，然后case study后针对问题检索相关论文

建议每天刷小红书和公众号扫描一下自己感兴趣的论文

还有就是多交流，ensemble learning

# 第四步

<**! IMPORTANT**>

最重要的是case study，主要看模型的thought

1. 先看golden patch和生成的patch在位置是否相同，相同就说明是模型改错了（虽然也有可能改不同的地方也能work，但是这次错了我们就假设它一定要在golden这个位置改），要从模型如何更好地fix出发，推荐memory或者TTS
2. 如果位置不同，文件相同，那就是最恶心的问题，模型可能看到了但是改错了！这个是最难搞定的问题，因为要让agent意识到哪个是root cause，推荐memory或者RL
3. 如果文件不同，那就看一下模型的轨迹是否检索过相关问题，如果检索过，那也是模型没意识到改错了
4. 如果没检索过，就注重提高模型对代码仓库结构的理解和对issue的理解，因为可能是模型理解错问题了，也可能是模型没检索到相关代码，图或者各种TTS
5. 如果没生成patch，那大概率是swe-agent或者openhands框架这种一直在检索代码，推荐tools分层或者显式告诉模型多少个步骤生成patch（**但这个不能放论文**）

现在fix的步骤差不多是：

1. 理解
2. 错误复现
3. 检索bug相关代码
4. **确定bug位置**
5. 生成patch
6. 写新测试案例
7. 结束

我是一直觉得错误定位没啥用，100个Actions是个佩奇都能定位到，关键是模型怎么意识到要改这个

当你想到了一个idea，你需要：
1. 先看当前领域比如代码，有没有人做过；
2. 再看别的领域有没有人做过一样的
3. 如果有，就把别人的方法复现一遍看看有没有什么缺点


# 第五步

当你有了一个比较make sense的方法，如何再进行提高呢？

建议先在全局数据集上测一遍，杜绝过拟合

找到一个和当前过程不互相依赖的阶段，比如你提高了错误复现，那么写新测试案例就明显不互相依赖。然后再进行新一轮迭代
